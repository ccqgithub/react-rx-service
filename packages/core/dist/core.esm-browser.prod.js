import{Subject as e,BehaviorSubject as t}from"rxjs";const s={logLevel:"development"===process.env.NODE_ENV?"info":"error",log:(e,t="info")=>{console&&console[t]&&console[t](e)}},o=e=>{Object.keys(s).forEach((t=>{const o=e[t];null!=o&&(s[t]=o)}))},r=(e,t="info",o=!0)=>{if(!o)return;const r=["info","warn","error","never"];r.indexOf(s.logLevel)>r.indexOf(t)||s.log(e,t)},i=Symbol("empty");class n{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class a{constructor(e,t){this._desc=e,this.factory=t?.factory}toString(){return`InjectionToken: ${this._desc}`}}const c=Symbol("inject:constructor:params"),l=(e,t={})=>(s,o,r)=>{if(void 0!==o)throw new Error("The @inject decorator can only be used on consturctor parameters!");const i=Reflect.getOwnMetadata(c,s)||[];i[r]={provide:e,optional:!!t.optional},Reflect.defineMetadata(c,i,s)};class u{constructor(e=[],t=null){this.parent=null,this.records=new Map,this.parent=t,e.forEach((e=>{let t=null;if("object"==typeof e){const s=e,o=["useValue","useClass","useExisiting","useFactory"];let i=0;o.forEach((e=>{void 0!==s[e]&&i++})),i>1&&r(`These keys [${o.join(",")}] can only use one, other will be ignored!`,"warn");const{useValue:n=null,...a}=s;t={...a,value:n}}else if("function"==typeof e&&"function"==typeof e.prototype.constructor){t={provide:e,useClass:e}}if(!t)throw r(e),new Error("Error provider onfig!");if(!(void 0!==t.value||t.useClass||t.useExisiting||t.useFactory||t.provide instanceof a&&t.useFactory))throw r(e),new Error("Error provider onfig!");this.records.set(t.provide,t)}))}isProvided(e){return!!this.records.has(e)||!!this.parent&&this.parent.isProvided(e)}get(e){const t=this.records.get(e);return t?(void 0===t.value&&this.$_initRecord(t),t.value||null):this.parent?this.parent.get(e):null}$_initRecord(e){if(e.provide instanceof a&&e.provide.factory){e.value=e.provide.factory(((t,s={})=>{const{optional:o}=s,i=this.get(t);if(!i&&!o)throw r(e),r(a),new Error("Can not find all deps in the DI tree when init the InjectionToken, please provide them before you use the InjectionToken's factory!");return i}))}if(e.useClass){const t=(Reflect.getOwnMetadata(c,e.useClass)||[]).map((t=>{if("object"!=typeof t)return;const{provide:s,optional:o}=t,i=this.get(s);if(!i&&!o)throw r(e),new Error("Can not find all deps in the DI tree when init the useClass, please provide them before you use the useClass!");return i}));e.value=new e.useClass(...t)}else if(e.useExisiting)e.value=this.get(e.useExisiting);else if(e.useFactory){e.value=e.useFactory(((t,s={})=>{const{optional:o}=s,i=this.get(t);if(!i&&!o)throw r(e),new Error("Can not find all deps in the DI tree when init the useFactory, please provide them before you use the useFactory!");return i}))}}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose()}this.parent=null,this.records.clear()}}class h extends n{constructor(s={}){super(),this.displayName="",this.$$={},this.$={},this.displayName||(this.displayName=this.constructor.name,r(`[Service ${this.displayName}]: For better debugging, you'd better add an attribute 'displayName' to each service class.`,"warn"));const o=s.state||{};Object.keys(o).forEach((s=>{this.$$[s]=void 0===o[s]||o[s]===i?new e:new t(o[s])}));(s.actions||[]).forEach((t=>{this.$[t]=new e})),Object.keys(this.$$).forEach((e=>{this.subscribe(this.$$[e],{next:t=>{r(`[Service ${this.displayName}]: set new state [${e}].`,"info"),r(t,"info")}})})),Object.keys(this.$).forEach((e=>{this.subscribe(this.$[e],{next:t=>{r(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),r(t,"info")}})}))}get state(){const e={};return Object.keys(this.$$).forEach((s=>{const o=this.$$[s];o instanceof t&&(e[s]=o.value)})),e}subscribe(e,...t){const s=e.subscribe(...t);this.beforeDispose((()=>{s.unsubscribe()}))}}export{n as Disposable,l as Inject,a as InjectionToken,u as Injector,h as Service,o as config,r as debug,i as empty};
