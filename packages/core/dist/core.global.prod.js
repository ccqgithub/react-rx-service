var RSCore=function(e,s){"use strict";const t={logLevel:"error",log:(e,s="info")=>{console&&console[s]&&console[s](e)}},r=(e,s="info",r=!0)=>{if(!r)return;const o=["info","warn","error","never"];o.indexOf(t.logLevel)>o.indexOf(s)||t.log(e,s)};class o{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class i{constructor(e=[],s=null){this.parent=null,this.records=new Map,this.parent=s,e.forEach((e=>{let s,t;if("object"==typeof e&&void 0!==e.provide&&(e.useClass||e.useValue))t=e.provide,s={value:e.useValue||null,useClass:e.useClass||null,dispose:e.dispose||null};else{if("function"!=typeof e)throw r(e),new Error("Error provider onfig!");t=e,s={value:null,useClass:e,dispose:null}}this.records.set(t,s)}))}isRegistered(e){return!!this.records.has(e)||!!this.parent&&this.parent.isRegistered(e)}get(e){const s=this.records.get(e);let t;if(s&&!s.value&&s.useClass&&(t=this.$_initClass(s.useClass),s.value=t),!s||!s.value)throw r(e,"error"),new Error("The service not be registered on this injector or any of the parent injector!");return s.value}$_initClass(e){const s=e.prototype.$_getParentInjector||null;e.prototype.$_getParentInjector=()=>this;const t=new e;return t.$_parentInjector=this,t.$_getParentInjector=null,e.prototype.$_getParentInjector=s,t}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose(e.value)}this.parent=null,this.records.clear()}static getParentInjector(e){let s=null;return"object"==typeof e.$_parentInjector?s=e.$_parentInjector:"function"==typeof e.$_getParentInjector&&(s=e.$_getParentInjector(e)),s}}return e.Disposable=o,e.Injector=i,e.Service=class extends o{constructor(e={}){super(),this.displayName="",this.$$={},this.$={},this.$_injector=new i(e.providers||[],i.getParentInjector(this)),this.beforeDispose((()=>{this.$_injector.dispose()})),this.displayName||(this.displayName=this.constructor.name,r(`[Service ${this.displayName}]: For better debugging, you'd better add an attribute 'displayName' to each service class.`,"warn"));const t=e.state||{};Object.keys(t).forEach((e=>{this.$$[e]=new s.BehaviorSubject(t[e])}));(e.actions||[]).forEach((e=>{this.$[e]=new s.Subject})),Object.keys(this.$$).forEach((e=>{this.useSubscribe(this.$$[e],{next:s=>{r(`[Service ${this.displayName}]: set new state [${e}].`,"info"),r(s,"info")}})})),Object.keys(this.$).forEach((e=>{this.useSubscribe(this.$[e],{next:s=>{r(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),r(s,"info")}})}))}get state(){const e={};return Object.keys(this.$$).forEach((s=>{e[s]=this.$$[s].value})),e}useService(e){return this.$_injector.get(e)}useSubscribe(e,...s){const t=e.subscribe(...s);this.beforeDispose((()=>{t.unsubscribe()}))}},e.config=e=>{Object.keys(t).forEach((s=>{void 0!==e[s]&&(t[s]=e[s])}))},Object.defineProperty(e,"__esModule",{value:!0}),e}({},rxjs);
