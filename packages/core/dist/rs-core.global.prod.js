var RSCore=function(e,s){"use strict";const t={logLevel:"error",log:(e,s="info")=>{console&&console[s]&&console[s](e)}},o=(e,s="info",o=!0)=>{if(!o)return;const i=["info","warn","error","never"];i.indexOf(t.logLevel)>i.indexOf(s)||t.log(e,s)},i=Symbol("empty");class r{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class n{constructor(e,s){this._desc=e,this.factory=s?.factory}toString(){return`InjectionToken: ${this._desc}`}}return e.Disposable=r,e.InjectionToken=n,e.Injector=class{constructor(e=[],s=null){this.parent=null,this.records=new Map,this.parent=s,e.forEach((e=>{let s=null;if("object"==typeof e){const t=e,i=["useValue","useClass","useExisiting","useFactory"];let r=0;i.forEach((e=>{void 0!==t[e]&&r++})),r>1&&o(`These keys [${i.join(",")}] can only use one, other will be ignored!`,"warn");const{useValue:n,...c}=t;s={...c,value:n}}else if("function"==typeof e&&"function"==typeof e.prototype.constructor){s={provide:e,useClass:e}}if(!s)throw o(e),new Error("Error provider onfig!");if(!(void 0!==s.value||s.useClass||s.useExisiting||s.useFactory||s.provide instanceof n&&s.useFactory))throw o(e),new Error("Error provider onfig!");this.records.set(s.provide,s)}))}isProvided(e){return!!this.records.has(e)||!!this.parent&&this.parent.isProvided(e)}get(e,s){const t=this.records.get(e);let o=null;if(t?(void 0===t.value&&this.$_initRecord(t),o=t.value||null):this.parent&&(o=this.parent.get(e,s)),!o&&!s?.optional)throw new Error("Service not be provided, and not optional!");return o}$_initRecord(e){const s={useService:(e,s)=>this.get(e,s)};e.provide instanceof n&&e.provide.factory&&(e.value=e.provide.factory(s)),e.useClass?e.value=new e.useClass(s):e.useExisiting?e.value=this.get(e.useExisiting):e.useFactory&&(e.value=e.useFactory(s))}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose()}this.parent=null,this.records.clear()}},e.Service=class extends r{constructor(e={}){super(),this.displayName="",this.$$={},this.$={},this.$e={};const t=e.state||{};Object.keys(t).forEach((e=>{this.$$[e]=new s.BehaviorSubject(t[e])}));(e.actions||[]).forEach((e=>{this.$[e]=new s.Subject}));(e.events||[]).forEach((e=>{this.$e[e]=new s.Subject})),Object.keys(this.$$).forEach((e=>{this.subscribe(this.$$[e],{next:s=>{o(`[Service ${this.displayName}]: set new state [${e}].`,"info"),o(s,"info")}})})),Object.keys(this.$).forEach((e=>{this.subscribe(this.$[e],{next:s=>{o(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),o(s,"info")}})})),Object.keys(this.$e).forEach((e=>{this.subscribe(this.$e[e],{next:s=>{o(`[Service ${this.displayName}]: emit new event [${e}].`,"info"),o(s,"info")}})}))}get state(){const e={};return Object.keys(this.$$).forEach((t=>{const o=this.$$[t];o instanceof s.BehaviorSubject&&(e[t]=o.value)})),e}subscribe(e,...s){const t=e.subscribe(...s);this.beforeDispose((()=>{t.unsubscribe()}))}},e.config=e=>{Object.keys(e).forEach((s=>{s in t&&void 0!==e[s]&&(t[s]=e[s])}))},e.debug=o,e.empty=i,Object.defineProperty(e,"__esModule",{value:!0}),e}({},rxjs);
