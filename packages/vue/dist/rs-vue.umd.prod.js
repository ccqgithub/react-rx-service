var e,r;e=this,r=function(e,r,s){const t={logLevel:"error",log:(e,r="info")=>{console&&console[r]&&console[r](e)}},o=(e,r="info",s=!0)=>{if(!s)return;const o=["info","warn","error","never"];o.indexOf(t.logLevel)>o.indexOf(r)||t.log(e,r)};class n{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class i{constructor(e,r){this._desc=e,this.factory=r?.factory}toString(){return`InjectionToken: ${this._desc}`}}class c{constructor(e=[],r=null){this.parent=null,this.records=new Map,this.parent=r,e.forEach((e=>{let r=null;if("object"==typeof e){const s=e,t=["useValue","useClass","useExisiting","useFactory"];let n=0;t.forEach((e=>{void 0!==s[e]&&n++})),n>1&&o(`These keys [${t.join(",")}] can only use one, other will be ignored!`,"warn");const{useValue:i,...c}=s;r={...c,value:i}}else"function"==typeof e&&"function"==typeof e.prototype.constructor&&(r={provide:e,useClass:e});if(!r)throw o(e),new Error("Error provider onfig!");if(!(void 0!==r.value||r.useClass||r.useExisiting||r.useFactory||r.provide instanceof i&&r.useFactory))throw o(e),new Error("Error provider onfig!");this.records.set(r.provide,r)}))}isProvided(e){return!!this.records.has(e)||!!this.parent&&this.parent.isProvided(e)}get(e,r){const s=this.records.get(e);let t=null;if(s?(void 0===s.value&&this.$_initRecord(s),t=s.value||null):this.parent&&(t=this.parent.get(e,r)),!t&&!r?.optional)throw new Error("Service not be provided, and not optional!");return t}$_initRecord(e){const r={useService:(e,r)=>this.get(e,r)};e.provide instanceof i&&e.provide.factory&&(e.value=e.provide.factory(r)),e.useClass?e.value=new e.useClass(r):e.useExisiting?e.value=this.get(e.useExisiting):e.useFactory&&(e.value=e.useFactory(r))}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose()}this.parent=null,this.records.clear()}}const u=Symbol("Injector Key"),a=Symbol("Instance Injector Key"),l=s.defineComponent({props:{providers:{type:Object,required:!0}},setup(e){const r=s.inject(u),t=new c(e.providers,r);s.provide(u,t)}});e.Disposable=n,e.InjectionToken=i,e.Injector=c,e.Service=class extends n{constructor(e={}){super(),this.displayName="",this.$={},this.$e={};const t=s.reactive(e.state||{}),n=s.readonly(t);this._state=t,this.state=n,(e.actions||[]).forEach((e=>{this.$[e]=new r.Subject})),(e.events||[]).forEach((e=>{this.$e[e]=new r.Subject})),Object.keys(this.$).forEach((e=>{this.subscribe(this.$[e],{next:r=>{o(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),o(r,"info")}})})),Object.keys(this.$e).forEach((e=>{this.subscribe(this.$e[e],{next:r=>{o(`[Service ${this.displayName}]: emit new event [${e}].`,"info"),o(r,"info")}})}))}setState(e){e(this._state)}subscribe(e,...r){const s=e.subscribe(...r);this.beforeDispose((()=>{s.unsubscribe()}))}},e.ServiceInjector=l,e.config=e=>{Object.keys(e).forEach((r=>{r in t&&void 0!==e[r]&&(t[r]=e[r])}))},e.debug=o,e.useBehavior=e=>{if(!(e instanceof r.BehaviorSubject))throw new Error("The useBehaviorState can only use with BehaviorSubject!");const t=s.ref(e.value),o=e.subscribe({next:e=>t.value=e});return s.onBeforeUnmount((()=>{o.unsubscribe()})),t},e.useGetService=()=>{const e=s.getCurrentInstance()[a]||s.inject(u,null);return(r,s)=>{if(!e){if(!s||!s.optional)throw new Error("Never register any injector!");return null}return e.get(r,s)}},e.useInjector=e=>{const r=s.getCurrentInstance(),t=s.inject(u,null),o=new c(e.providers,t);r[a]=o,s.provide(u,o)},e.useObservable=(e,r)=>{const t=s.ref(r),o=e.subscribe({next:e=>t.value=e});return s.onBeforeUnmount((()=>{o.unsubscribe()})),t},e.useObservableError=(e,r=null,t={onlyAfter:!0})=>{const o=s.ref(r);let n=!1;const i=e.subscribe({error:e=>{t.onlyAfter&&!n||(o.value=e)}});return n=!0,s.onBeforeUnmount((()=>{i.unsubscribe()})),o},e.useService=(e,r)=>{const t=s.getCurrentInstance()[a]||s.inject(u,null);if(!t){if(!r||!r.optional)throw new Error("Never register any injectorÃ¥!");return null}return t.get(e,r)},e.useSubscribe=function(e,r){const t=e.subscribe(r);s.onBeforeUnmount((()=>{t.unsubscribe()}))},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("rxjs"),require("vue")):"function"==typeof define&&define.amd?define(["exports","rxjs","vue"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).RSVue={},e.rxjs,e.Vue);
