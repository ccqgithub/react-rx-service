import e,{createContext as t,useContext as s,useCallback as o,useState as r,useEffect as n,useMemo as i}from"react";import{Subject as c,BehaviorSubject as a}from"rxjs";const u={logLevel:"development"===process.env.NODE_ENV?"info":"error",log:(e,t="info")=>{console&&console[t]&&console[t](e)}},l=e=>{Object.keys(u).forEach((t=>{const s=e[t];null!=s&&(u[t]=s)}))},h=(e,t="info",s=!0)=>{if(!s)return;const o=["info","warn","error","never"];o.indexOf(u.logLevel)>o.indexOf(t)||u.log(e,t)},f=Symbol("empty");class d{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class p{constructor(e,t){this._desc=e,this.factory=t?.factory}toString(){return`InjectionToken: ${this._desc}`}}const v=Symbol("inject:constructor:params"),y=(e,t={})=>(s,o,r)=>{if(void 0!==o)throw new Error("The @inject decorator can only be used on consturctor parameters!");const n=Reflect.getOwnMetadata(v,s)||[];n[r]={provide:e,optional:!!t.optional},Reflect.defineMetadata(v,n,s)};class b{constructor(e=[],t=null){this.parent=null,this.records=new Map,this.parent=t,e.forEach((e=>{let t=null;if("object"==typeof e){const s=e,o=["useValue","useClass","useExisiting","useFactory"];let r=0;o.forEach((e=>{void 0!==s[e]&&r++})),r>1&&h(`These keys [${o.join(",")}] can only use one, other will be ignored!`,"warn");const{useValue:n=null,...i}=s;t={...i,value:n}}else if("function"==typeof e&&"function"==typeof e.prototype.constructor){t={provide:e,useClass:e}}if(!t)throw h(e),new Error("Error provider onfig!");if(!(void 0!==t.value||t.useClass||t.useExisiting||t.useFactory||t.provide instanceof p&&t.useFactory))throw h(e),new Error("Error provider onfig!");this.records.set(t.provide,t)}))}isProvided(e){return!!this.records.has(e)||!!this.parent&&this.parent.isProvided(e)}get(e){const t=this.records.get(e);return t?(void 0===t.value&&this.$_initRecord(t),t.value||null):this.parent?this.parent.get(e):null}$_initRecord(e){if(e.provide instanceof p&&e.provide.factory){e.value=e.provide.factory(((t,s={})=>{const{optional:o}=s,r=this.get(t);if(!r&&!o)throw h(e),h(p),new Error("Can not find all deps in the DI tree when init the InjectionToken, please provide them before you use the InjectionToken's factory!");return r}))}if(e.useClass){const t=(Reflect.getOwnMetadata(v,e.useClass)||[]).map((t=>{if("object"!=typeof t)return;const{provide:s,optional:o}=t,r=this.get(s);if(!r&&!o)throw h(e),new Error("Can not find all deps in the DI tree when init the useClass, please provide them before you use the useClass!");return r}));e.value=new e.useClass(...t)}else if(e.useExisiting)e.value=this.get(e.useExisiting);else if(e.useFactory){e.value=e.useFactory(((t,s={})=>{const{optional:o}=s,r=this.get(t);if(!r&&!o)throw h(e),new Error("Can not find all deps in the DI tree when init the useFactory, please provide them before you use the useFactory!");return r}))}}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose()}this.parent=null,this.records.clear()}}class w extends d{constructor(e={}){super(),this.displayName="",this.$$={},this.$={},this.displayName||(this.displayName=this.constructor.name,h(`[Service ${this.displayName}]: For better debugging, you'd better add an attribute 'displayName' to each service class.`,"warn"));const t=e.state||{};Object.keys(t).forEach((e=>{this.$$[e]=void 0===t[e]||t[e]===f?new c:new a(t[e])}));(e.actions||[]).forEach((e=>{this.$[e]=new c})),Object.keys(this.$$).forEach((e=>{this.subscribe(this.$$[e],{next:t=>{h(`[Service ${this.displayName}]: set new state [${e}].`,"info"),h(t,"info")}})})),Object.keys(this.$).forEach((e=>{this.subscribe(this.$[e],{next:t=>{h(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),h(t,"info")}})}))}get state(){const e={};return Object.keys(this.$$).forEach((t=>{const s=this.$$[t];s instanceof a&&(e[t]=s.value)})),e}subscribe(e,...t){const s=e.subscribe(...t);this.beforeDispose((()=>{s.unsubscribe()}))}}const g=t(new b),$=t=>{const o=s(g),{providers:r=[],children:n}=t,i=new b(r,o);return e.createElement(g.Provider,{value:i},n)},E=e=>{const t=s(g);return"function"==typeof e.children?e.children({getService:(e,s={})=>{const{optional:o=!1}=s;if(!t.get(e)&&!o)throw h(e,"error"),new Error("Can not find the service, you provide it?")}}):e.children};function m(){const e=s(g);return o((t=>e.get(t)),[e])}const j=e=>m()(e);function x(e){const t=m();return e.map((e=>t(e)))}function C(e,t){const[s,o]=r((()=>e instanceof a?e.value:t));return n((()=>{const t=e.subscribe({next:e=>o(e)});return()=>{t.unsubscribe()}}),[e]),s}function O(e,t=!1){const[s,o]=r(null),a=i((()=>e instanceof c&&t&&e.hasError),[e,t]);return n((()=>{if(a)return;const t=e.subscribe({error:e=>{o(e)}});return()=>{t.unsubscribe()}}),[e,a]),s}export{d as Disposable,y as Inject,p as InjectionToken,b as Injector,w as Service,E as ServiceConsumer,g as ServiceContext,$ as ServiceProvider,l as config,h as debug,f as empty,m as useGetService,C as useObservable,O as useObservableError,j as useService,x as useServices};
