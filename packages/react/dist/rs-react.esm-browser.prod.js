import{BehaviorSubject as e,Subject as t}from"rxjs";import r,{createContext as s,useRef as o,useContext as n,useState as i,useEffect as c,useCallback as u,useMemo as a}from"react";const l={logLevel:"error",log:(e,t="info")=>{console&&console[t]&&console[t](e)}},h=e=>{Object.keys(e).forEach((t=>{t in l&&void 0!==e[t]&&(l[t]=e[t])}))},f=(e,t="info",r=!0)=>{if(!r)return;const s=["info","warn","error","never"];s.indexOf(l.logLevel)>s.indexOf(t)||l.log(e,t)};class d{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class p{constructor(e,t){this._desc=e,this.factory=t?.factory}toString(){return`InjectionToken: ${this._desc}`}}class v{constructor(e=[],t=null){this.parent=null,this.records=new Map,this.parent=t,e.forEach((e=>{let t=null;if("object"==typeof e){const r=e,s=["useValue","useClass","useExisiting","useFactory"];let o=0;s.forEach((e=>{void 0!==r[e]&&o++})),o>1&&f(`These keys [${s.join(",")}] can only use one, other will be ignored!`,"warn");const{useValue:n,...i}=r;t={...i,value:n}}else if("function"==typeof e&&"function"==typeof e.prototype.constructor){t={provide:e,useClass:e}}if(!t)throw f(e),new Error("Error provider onfig!");if(!(void 0!==t.value||t.useClass||t.useExisiting||t.useFactory||t.provide instanceof p&&t.useFactory))throw f(e),new Error("Error provider onfig!");this.records.set(t.provide,t)}))}isProvided(e){return!!this.records.has(e)||!!this.parent&&this.parent.isProvided(e)}get(e,t){const r=this.records.get(e);let s=null;if(r?(void 0===r.value&&this.$_initRecord(r),s=r.value||null):this.parent&&(s=this.parent.get(e,t)),!s&&!t?.optional)throw new Error("Service not be provided, and not optional!");return s}$_initRecord(e){const t={useService:(e,t)=>this.get(e,t)};e.provide instanceof p&&e.provide.factory&&(e.value=e.provide.factory(t)),e.useClass?e.value=new e.useClass(t):e.useExisiting?e.value=this.get(e.useExisiting):e.useFactory&&(e.value=e.useFactory(t))}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose()}this.parent=null,this.records.clear()}}class b extends d{constructor(r={}){super(),this.displayName="",this.$$={},this.$={},this.$e={};const s=r.state||{};Object.keys(s).forEach((t=>{this.$$[t]=new e(s[t])}));(r.actions||[]).forEach((e=>{this.$[e]=new t}));(r.events||[]).forEach((e=>{this.$e[e]=new t})),Object.keys(this.$$).forEach((e=>{this.subscribe(this.$$[e],{next:t=>{f(`[Service ${this.displayName}]: set new state [${e}].`,"info"),f(t,"info")}})})),Object.keys(this.$).forEach((e=>{this.subscribe(this.$[e],{next:t=>{f(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),f(t,"info")}})})),Object.keys(this.$e).forEach((e=>{this.subscribe(this.$e[e],{next:t=>{f(`[Service ${this.displayName}]: emit new event [${e}].`,"info"),f(t,"info")}})}))}get state(){const t={};return Object.keys(this.$$).forEach((r=>{const s=this.$$[r];s instanceof e&&(t[r]=s.value)})),t}subscribe(e,...t){const r=e.subscribe(...t);this.beforeDispose((()=>{r.unsubscribe()}))}}const $=s(new v),y=e=>{const t=o(!0),s=n($),{providers:u=[],children:a}=e,[l,h]=i((()=>new v(u,s)));return c((()=>{if(t.current)return void(t.current=!1);const e=new v(u,s);h(e)}),[u,s]),r.createElement($.Provider,{value:l},a)},w=e=>{const t=n($);return"function"==typeof e.children?e.children({getService:(e,r)=>t.get(e,r)}):e.children},E=()=>{const e=n($);return u(((t,r)=>e.get(t,r)),[e])},g=(e,t)=>E()(e,t),x=(e,t)=>{const[r,s]=i(t);return c((()=>{const t=e.subscribe({next:e=>s(e)});return()=>{t.unsubscribe()}}),[e]),r},m=t=>{if(!(t instanceof e))throw new Error("The useBehaviorState can only use with BehaviorSubject!");const[r,s]=i(t.value);return c((()=>{const e=t.subscribe({next:e=>s(e)});return()=>{e.unsubscribe()}}),[t]),r},j=(e,t=null,r={onlyAfter:!0})=>{const[s,o]=i(t);return c((()=>{let t=!1;const s=e.subscribe({error:e=>{r.onlyAfter&&!t||o(e)}});return t=!0,()=>{s.unsubscribe()}}),[e,r.onlyAfter]),s};function S(e,t,r,s){const n=a((()=>"object"==typeof t&&null!==t?t:{next:t,error:r,complete:s}),[t,r,s]),i=o(n);i.current=n,c((()=>{const t=e.subscribe((e=>i.current.next&&i.current.next(e)),(e=>i.current.error&&i.current.error(e)),(()=>i.current.complete&&i.current.complete()));return()=>{t.unsubscribe()}}),[e,i])}export{d as Disposable,p as InjectionToken,v as Injector,b as Service,w as ServiceConsumer,y as ServiceInjector,h as config,f as debug,m as useBehavior,E as useGetService,x as useObservable,j as useObservableError,g as useService,S as useSubscribe};
