var RSReact=function(e,t,s){"use strict";function r(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var o=r(s);const n={logLevel:"error",log:(e,t="info")=>{console&&console[t]&&console[t](e)}},i=(e,t="info",s=!0)=>{if(!s)return;const r=["info","warn","error","never"];r.indexOf(n.logLevel)>r.indexOf(t)||n.log(e,t)};class c{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class u{constructor(e,t){this._desc=e,this.factory=t?.factory}toString(){return`InjectionToken: ${this._desc}`}}class a{constructor(e=[],t=null){this.parent=null,this.records=new Map,this.parent=t,e.forEach((e=>{let t=null;if("object"==typeof e){const s=e,r=["useValue","useClass","useExisiting","useFactory"];let o=0;r.forEach((e=>{void 0!==s[e]&&o++})),o>1&&i(`These keys [${r.join(",")}] can only use one, other will be ignored!`,"warn");const{useValue:n,...c}=s;t={...c,value:n}}else if("function"==typeof e&&"function"==typeof e.prototype.constructor){t={provide:e,useClass:e}}if(!t)throw i(e),new Error("Error provider onfig!");if(!(void 0!==t.value||t.useClass||t.useExisiting||t.useFactory||t.provide instanceof u&&t.useFactory))throw i(e),new Error("Error provider onfig!");this.records.set(t.provide,t)}))}isProvided(e){return!!this.records.has(e)||!!this.parent&&this.parent.isProvided(e)}get(e,t){const s=this.records.get(e);let r=null;if(s?(void 0===s.value&&this.$_initRecord(s),r=s.value||null):this.parent&&(r=this.parent.get(e,t)),!r&&!t?.optional)throw new Error("Service not be provided, and not optional!");return r}$_initRecord(e){const t={useService:(e,t)=>this.get(e,t)};e.provide instanceof u&&e.provide.factory&&(e.value=e.provide.factory(t)),e.useClass?e.value=new e.useClass(t):e.useExisiting?e.value=this.get(e.useExisiting):e.useFactory&&(e.value=e.useFactory(t))}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose()}this.parent=null,this.records.clear()}}const l=s.createContext(new a),f=()=>{const e=s.useContext(l);return s.useCallback(((t,s)=>e.get(t,s)),[e])};return e.Disposable=c,e.InjectionToken=u,e.Injector=a,e.Service=class extends c{constructor(e={}){super(),this.displayName="",this.$$={},this.$={},this.$e={};const s=e.state||{};Object.keys(s).forEach((e=>{this.$$[e]=new t.BehaviorSubject(s[e])}));(e.actions||[]).forEach((e=>{this.$[e]=new t.Subject}));(e.events||[]).forEach((e=>{this.$e[e]=new t.Subject})),Object.keys(this.$$).forEach((e=>{this.subscribe(this.$$[e],{next:t=>{i(`[Service ${this.displayName}]: set new state [${e}].`,"info"),i(t,"info")}})})),Object.keys(this.$).forEach((e=>{this.subscribe(this.$[e],{next:t=>{i(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),i(t,"info")}})})),Object.keys(this.$e).forEach((e=>{this.subscribe(this.$e[e],{next:t=>{i(`[Service ${this.displayName}]: emit new event [${e}].`,"info"),i(t,"info")}})}))}get state(){const e={};return Object.keys(this.$$).forEach((s=>{const r=this.$$[s];r instanceof t.BehaviorSubject&&(e[s]=r.value)})),e}subscribe(e,...t){const s=e.subscribe(...t);this.beforeDispose((()=>{s.unsubscribe()}))}},e.ServiceConsumer=e=>{const t=s.useContext(l);return"function"==typeof e.children?e.children({getService:(e,s)=>t.get(e,s)}):e.children},e.ServiceInjector=e=>{const t=s.useRef(!0),r=s.useContext(l),{providers:n=[],children:i}=e,[c,u]=s.useState((()=>new a(n,r)));return s.useEffect((()=>{if(t.current)return void(t.current=!1);const e=new a(n,r);u(e)}),[n,r]),o.createElement(l.Provider,{value:c},i)},e.config=e=>{Object.keys(e).forEach((t=>{t in n&&void 0!==e[t]&&(n[t]=e[t])}))},e.debug=i,e.useBehavior=e=>{if(!(e instanceof t.BehaviorSubject))throw new Error("The useBehaviorState can only use with BehaviorSubject!");const[r,o]=s.useState(e.value);return s.useEffect((()=>{const t=e.subscribe({next:e=>o(e)});return()=>{t.unsubscribe()}}),[e]),r},e.useGetService=f,e.useObservable=(e,t)=>{const[r,o]=s.useState(t);return s.useEffect((()=>{const t=e.subscribe({next:e=>o(e)});return()=>{t.unsubscribe()}}),[e]),r},e.useObservableError=(e,t=null,r={onlyAfter:!0})=>{const[o,n]=s.useState(t);return s.useEffect((()=>{let t=!1;const s=e.subscribe({error:e=>{r.onlyAfter&&!t||n(e)}});return t=!0,()=>{s.unsubscribe()}}),[e,r.onlyAfter]),o},e.useService=(e,t)=>f()(e,t),e.useSubscribe=function(e,t,r,o){const n=s.useMemo((()=>"object"==typeof t&&null!==t?t:{next:t,error:r,complete:o}),[t,r,o]),i=s.useRef(n);i.current=n,s.useEffect((()=>{const t=e.subscribe((e=>i.current.next&&i.current.next(e)),(e=>i.current.error&&i.current.error(e)),(()=>i.current.complete&&i.current.complete()));return()=>{t.unsubscribe()}}),[e,i])},Object.defineProperty(e,"__esModule",{value:!0}),e}({},rxjs,React);
