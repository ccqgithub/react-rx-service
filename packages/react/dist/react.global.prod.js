var RSReact=function(e,t,s){"use strict";function r(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var o=r(t);const n={logLevel:"development"===process.env.NODE_ENV?"info":"error",log:(e,t="info")=>{console&&console[t]&&console[t](e)}},i=(e,t="info",s=!0)=>{if(!s)return;const r=["info","warn","error","never"];r.indexOf(n.logLevel)>r.indexOf(t)||n.log(e,t)},c=Symbol("empty");class a{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class u{constructor(e,t){this._desc=e,this.factory=t?.factory}toString(){return`InjectionToken: ${this._desc}`}}const l=Symbol("inject:constructor:params");class h{constructor(e=[],t=null){this.parent=null,this.records=new Map,this.parent=t,e.forEach((e=>{let t=null;if("object"==typeof e){const s=e,r=["useValue","useClass","useExisiting","useFactory"];let o=0;r.forEach((e=>{void 0!==s[e]&&o++})),o>1&&i(`These keys [${r.join(",")}] can only use one, other will be ignored!`,"warn");const{useValue:n=null,...c}=s;t={...c,value:n}}else if("function"==typeof e&&"function"==typeof e.prototype.constructor){t={provide:e,useClass:e}}if(!t)throw i(e),new Error("Error provider onfig!");if(!(void 0!==t.value||t.useClass||t.useExisiting||t.useFactory||t.provide instanceof u&&t.useFactory))throw i(e),new Error("Error provider onfig!");this.records.set(t.provide,t)}))}isProvided(e){return!!this.records.has(e)||!!this.parent&&this.parent.isProvided(e)}get(e){const t=this.records.get(e);return t?(void 0===t.value&&this.$_initRecord(t),t.value||null):this.parent?this.parent.get(e):null}$_initRecord(e){if(e.provide instanceof u&&e.provide.factory){e.value=e.provide.factory(((t,s={})=>{const{optional:r}=s,o=this.get(t);if(!o&&!r)throw i(e),i(u),new Error("Can not find all deps in the DI tree when init the InjectionToken, please provide them before you use the InjectionToken's factory!");return o}))}if(e.useClass){const t=(Reflect.getOwnMetadata(l,e.useClass)||[]).map((t=>{if("object"!=typeof t)return;const{provide:s,optional:r}=t,o=this.get(s);if(!o&&!r)throw i(e),new Error("Can not find all deps in the DI tree when init the useClass, please provide them before you use the useClass!");return o}));e.value=new e.useClass(...t)}else if(e.useExisiting)e.value=this.get(e.useExisiting);else if(e.useFactory){e.value=e.useFactory(((t,s={})=>{const{optional:r}=s,o=this.get(t);if(!o&&!r)throw i(e),new Error("Can not find all deps in the DI tree when init the useFactory, please provide them before you use the useFactory!");return o}))}}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose()}this.parent=null,this.records.clear()}}const f=t.createContext(new h);function d(){const e=t.useContext(f);return t.useCallback((t=>e.get(t)),[e])}return e.Disposable=a,e.Inject=(e,t={})=>(s,r,o)=>{if(void 0!==r)throw new Error("The @inject decorator can only be used on consturctor parameters!");const n=Reflect.getOwnMetadata(l,s)||[];n[o]={provide:e,optional:!!t.optional},Reflect.defineMetadata(l,n,s)},e.InjectionToken=u,e.Injector=h,e.Service=class extends a{constructor(e={}){super(),this.displayName="",this.$$={},this.$={},this.displayName||(this.displayName=this.constructor.name,i(`[Service ${this.displayName}]: For better debugging, you'd better add an attribute 'displayName' to each service class.`,"warn"));const t=e.state||{};Object.keys(t).forEach((e=>{this.$$[e]=void 0===t[e]||t[e]===c?new s.Subject:new s.BehaviorSubject(t[e])}));(e.actions||[]).forEach((e=>{this.$[e]=new s.Subject})),Object.keys(this.$$).forEach((e=>{this.subscribe(this.$$[e],{next:t=>{i(`[Service ${this.displayName}]: set new state [${e}].`,"info"),i(t,"info")}})})),Object.keys(this.$).forEach((e=>{this.subscribe(this.$[e],{next:t=>{i(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),i(t,"info")}})}))}get state(){const e={};return Object.keys(this.$$).forEach((t=>{const r=this.$$[t];r instanceof s.BehaviorSubject&&(e[t]=r.value)})),e}subscribe(e,...t){const s=e.subscribe(...t);this.beforeDispose((()=>{s.unsubscribe()}))}},e.ServiceConsumer=e=>{const s=t.useContext(f);return"function"==typeof e.children?e.children({getService:(e,t={})=>{const{optional:r=!1}=t;if(!s.get(e)&&!r)throw i(e,"error"),new Error("Can not find the service, you provide it?")}}):e.children},e.ServiceContext=f,e.ServiceProvider=e=>{const s=t.useContext(f),{providers:r=[],children:n}=e,i=new h(r,s);return o.createElement(f.Provider,{value:i},n)},e.config=e=>{Object.keys(n).forEach((t=>{const s=e[t];null!=s&&(n[t]=s)}))},e.debug=i,e.empty=c,e.useGetService=d,e.useObservable=function(e,r){const[o,n]=t.useState((()=>e instanceof s.BehaviorSubject?e.value:r));return t.useEffect((()=>{const t=e.subscribe({next:e=>n(e)});return()=>{t.unsubscribe()}}),[e]),o},e.useObservableError=function(e,r=!1){const[o,n]=t.useState(null),i=t.useMemo((()=>e instanceof s.Subject&&r&&e.hasError),[e,r]);return t.useEffect((()=>{if(i)return;const t=e.subscribe({error:e=>{n(e)}});return()=>{t.unsubscribe()}}),[e,i]),o},e.useService=e=>d()(e),e.useServices=function(e){const t=d();return e.map((e=>t(e)))},Object.defineProperty(e,"__esModule",{value:!0}),e}({},React,rxjs);
