var RSReact=function(e,t,s){"use strict";function r(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var n=r(t);const o={logLevel:"error",log:(e,t="info")=>{console&&console[t]&&console[t](e)}},i=(e,t="info",s=!0)=>{if(!s)return;const r=["info","warn","error","never"];r.indexOf(o.logLevel)>r.indexOf(t)||o.log(e,t)};class c{constructor(){this.$_disposers=[]}beforeDispose(e){this.$_disposers.push(e)}dispose(){this.$_disposers.forEach((e=>{e()}))}}class u{constructor(e=[],t=null){this.parent=null,this.records=new Map,this.parent=t,e.forEach((e=>{let t,s;if("object"==typeof e&&void 0!==e.provide&&(e.useClass||e.useValue))s=e.provide,t={value:e.useValue||null,useClass:e.useClass||null,dispose:e.dispose||null};else{if("function"!=typeof e)throw i(e),new Error("Error provider onfig!");s=e,t={value:null,useClass:e,dispose:null}}this.records.set(s,t)}))}isRegistered(e){return!!this.records.has(e)||!!this.parent&&this.parent.isRegistered(e)}get(e){const t=this.records.get(e);let s;if(t&&!t.value&&t.useClass&&(s=this.$_initClass(t.useClass),t.value=s),!t||!t.value)throw i(e,"error"),new Error("The service not be registered on this injector or any of the parent injector!");return t.value}$_initClass(e){const t=e.prototype.$_getParentInjector||null;e.prototype.$_getParentInjector=()=>this;const s=new e;return s.$_parentInjector=this,s.$_getParentInjector=null,e.prototype.$_getParentInjector=t,s}dispose(){for(const[,e]of this.records){if(!e.value)return;e.dispose?e.dispose(e.value):"function"==typeof e.value.dispose&&e.value.dispose(e.value)}this.parent=null,this.records.clear()}static getParentInjector(e){let t=null;return"object"==typeof e.$_parentInjector?t=e.$_parentInjector:"function"==typeof e.$_getParentInjector&&(t=e.$_getParentInjector(e)),t}}const a=t.createContext(new u);function l(){const e=t.useContext(a);return t.useCallback((t=>e.get(t)),[e])}return e.Disposable=c,e.Injector=u,e.Service=class extends c{constructor(e={}){super(),this.displayName="",this.$$={},this.$={},this.$_injector=new u(e.providers||[],u.getParentInjector(this)),this.beforeDispose((()=>{this.$_injector.dispose()})),this.displayName||(this.displayName=this.constructor.name,i(`[Service ${this.displayName}]: For better debugging, you'd better add an attribute 'displayName' to each service class.`,"warn"));const t=e.state||{};Object.keys(t).forEach((e=>{this.$$[e]=new s.BehaviorSubject(t[e])}));(e.actions||[]).forEach((e=>{this.$[e]=new s.Subject})),Object.keys(this.$$).forEach((e=>{this.useSubscribe(this.$$[e],{next:t=>{i(`[Service ${this.displayName}]: set new state [${e}].`,"info"),i(t,"info")}})})),Object.keys(this.$).forEach((e=>{this.useSubscribe(this.$[e],{next:t=>{i(`[Service ${this.displayName}]: receive new action [${e}].`,"info"),i(t,"info")}})}))}get state(){const e={};return Object.keys(this.$$).forEach((t=>{e[t]=this.$$[t].value})),e}useService(e){return this.$_injector.get(e)}useSubscribe(e,...t){const s=e.subscribe(...t);this.beforeDispose((()=>{s.unsubscribe()}))}},e.ServiceConsumer=e=>{const s=t.useContext(a),r=e=>s.get(e),{provides:n=[]}=e,o=n.map((e=>r(e)));return"function"==typeof e.children?e.children({services:o,getService:r}):e.children},e.ServiceContext=a,e.ServiceProvider=e=>{const s=t.useContext(a),{providers:r=[],children:o}=e,i=new u(r,s);return n.createElement(a.Provider,{value:i},o)},e.config=e=>{Object.keys(o).forEach((t=>{void 0!==e[t]&&(o[t]=e[t])}))},e.useGetService=l,e.useObservable=function(e,r){const[n,o]=t.useState((()=>e instanceof s.BehaviorSubject?e.value:r));return t.useEffect((()=>{const t=e.subscribe({next:e=>o(e)});return()=>{t.unsubscribe()}}),[e]),n},e.useObservableError=function(e,r=!1){const[n,o]=t.useState(null),i=t.useMemo((()=>e instanceof s.Subject&&r&&e.hasError),[e,r]);return t.useEffect((()=>{if(i)return;const t=e.subscribe({error:e=>{o(e)}});return()=>{t.unsubscribe()}}),[e,i]),n},e.useService=function(e){return l()(e)},e.useServices=function(e){const t=l();return e.map((e=>t(e)))},Object.defineProperty(e,"__esModule",{value:!0}),e}({},React,rxjs);
